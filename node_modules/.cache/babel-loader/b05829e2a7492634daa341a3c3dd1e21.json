{"ast":null,"code":"import { useEffect, useCallback, useRef } from 'react'; // make API calls and pass the returned data via dispatch\n\nexport const useFetch = (data, dispatch) => {\n  useEffect(() => {\n    dispatch({\n      type: 'FETCHING_IMAGES',\n      fetching: true\n    });\n    fetch(`https://picsum.photos/v2/list?page=${data.page}&limit=10`).then(data => data.json()).then(images => {\n      dispatch({\n        type: 'STACK_IMAGES',\n        images\n      });\n      dispatch({\n        type: 'FETCHING_IMAGES',\n        fetching: false\n      });\n    }).catch(e => {\n      // handle error\n      dispatch({\n        type: 'FETCHING_IMAGES',\n        fetching: false\n      });\n      return e;\n    });\n  }, [dispatch, data.page]);\n}; // infinite scrolling with intersection observer\n\nexport const useInfiniteScroll = (scrollRef, dispatch) => {\n  const scrollObserver = useCallback(node => {\n    new IntersectionObserver(entries => {\n      entries.forEach(en => {\n        if (en.intersectionRatio > 0) {\n          dispatch({\n            type: 'ADVANCE_PAGE'\n          });\n        }\n      });\n    }).observe(node);\n  }, [dispatch]);\n  useEffect(() => {\n    if (scrollRef.current) {\n      scrollObserver(scrollRef.current);\n    }\n  }, [scrollObserver, scrollRef]);\n}; // lazy load images with intersection observer\n\nexport const useLazyLoading = (imgSelector, items) => {\n  const imgObserver = useCallback(node => {\n    const intObs = new IntersectionObserver(entries => {\n      entries.forEach(en => {\n        if (en.intersectionRatio > 0) {\n          const currentImg = en.target;\n          const newImgSrc = currentImg.dataset.src; // only swap out the image source if the new url exists\n\n          if (!newImgSrc) {\n            console.error('Image source is invalid');\n          } else {\n            currentImg.src = newImgSrc;\n          }\n\n          intObs.unobserve(node);\n        }\n      });\n    });\n    intObs.observe(node);\n  }, []);\n  const imagesRef = useRef(null);\n  useEffect(() => {\n    imagesRef.current = document.querySelectorAll(imgSelector);\n\n    if (imagesRef.current) {\n      imagesRef.current.forEach(img => imgObserver(img));\n    }\n  }, [imgObserver, imagesRef, imgSelector, items]);\n};","map":{"version":3,"sources":["C:/Users/aisha/Desktop/React-Infinite-Scroll-and-Lazy-Loading/src/customHooks.js"],"names":["useEffect","useCallback","useRef","useFetch","data","dispatch","type","fetching","fetch","page","then","json","images","catch","e","useInfiniteScroll","scrollRef","scrollObserver","node","IntersectionObserver","entries","forEach","en","intersectionRatio","observe","current","useLazyLoading","imgSelector","items","imgObserver","intObs","currentImg","target","newImgSrc","dataset","src","console","error","unobserve","imagesRef","document","querySelectorAll","img"],"mappings":"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","sourcesContent":["import { useEffect, useCallback, useRef } from 'react';\r\n\r\n// make API calls and pass the returned data via dispatch\r\nexport const useFetch = (data, dispatch) => {\r\n  useEffect(() => {\r\n    dispatch({ type: 'FETCHING_IMAGES', fetching: true })\r\n    fetch(`https://picsum.photos/v2/list?page=${data.page}&limit=10`)\r\n      .then(data => data.json())\r\n      .then(images => {\r\n        dispatch({ type: 'STACK_IMAGES', images })\r\n        dispatch({ type: 'FETCHING_IMAGES', fetching: false })\r\n      })\r\n      .catch(e => {\r\n        // handle error\r\n        dispatch({ type: 'FETCHING_IMAGES', fetching: false })\r\n        return e;\r\n      })\r\n  }, [dispatch, data.page])\r\n}\r\n\r\n// infinite scrolling with intersection observer\r\nexport const useInfiniteScroll = (scrollRef, dispatch) => {\r\n  const scrollObserver = useCallback(\r\n    node => {\r\n      new IntersectionObserver(entries => {\r\n        entries.forEach(en => {\r\n          if (en.intersectionRatio > 0) {\r\n            dispatch({ type: 'ADVANCE_PAGE' });\r\n          }\r\n        });\r\n      }).observe(node);\r\n    },\r\n    [dispatch]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (scrollRef.current) {\r\n      scrollObserver(scrollRef.current);\r\n    }\r\n  }, [scrollObserver, scrollRef]);\r\n}\r\n\r\n// lazy load images with intersection observer\r\nexport const useLazyLoading = (imgSelector, items) => {\r\n  const imgObserver = useCallback(node => {\r\n    const intObs = new IntersectionObserver(entries => {\r\n      entries.forEach(en => {\r\n        if (en.intersectionRatio > 0) {\r\n          const currentImg = en.target;\r\n          const newImgSrc = currentImg.dataset.src;\r\n\r\n          // only swap out the image source if the new url exists\r\n          if (!newImgSrc) {\r\n            console.error('Image source is invalid');\r\n          } else {\r\n            currentImg.src = newImgSrc;\r\n          }\r\n          intObs.unobserve(node);\r\n        }\r\n      });\r\n    })\r\n    intObs.observe(node);\r\n  }, []);\r\n\r\n  const imagesRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    imagesRef.current = document.querySelectorAll(imgSelector);\r\n\r\n    if (imagesRef.current) {\r\n      imagesRef.current.forEach(img => imgObserver(img));\r\n    }\r\n  }, [imgObserver, imagesRef, imgSelector, items])\r\n}\r\n"]},"metadata":{},"sourceType":"module"}